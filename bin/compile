#!/bin/bash

set -e
shopt -s dotglob

basedir="$( cd -P "$( dirname "$0" )" && pwd )"

source "$basedir/../conf/buildpack.conf"

if [ -n "$BUILDPACK_DEBUG" ]; then
    set -x
fi

BUILD_DIR="$1"
CACHE_DIR="$2"

cd "$BUILD_DIR"
mkdir -p "$CACHE_DIR/package"

function fetch_engine_package() {
    local engine="$1"
    local version="$2"
    local location="$3"

    fetch_package "${engine}-${version}" "$location"
}

function fetch_package() {
    local package="$1"
    local location="$2"

    mkdir -p "$location"

    local checksum_url="http://${S3_BUCKET}.s3.amazonaws.com/package/${package}.md5"
    local package_url="http://${S3_BUCKET}.s3.amazonaws.com/package/${package}.tgz"
    local checksum=$(curl "$checksum_url" 2> /dev/null)
    local cache_checksum=

    if [ -f "$CACHE_DIR/package/${package}.md5" ]; then
        local cache_checksum=$(cat "$CACHE_DIR/package/${package}.md5")
    fi

    mkdir -p "$CACHE_DIR/package/$(dirname "$package")"

    if [ "$cache_checksum" != "$checksum" ]; then
        curl "$package_url" -L -s > "$CACHE_DIR/package/${package}.tgz"
        echo "$checksum" > "$CACHE_DIR/package/${package}.md5"
    else
        echo "Checksums match. Fetching from cache."
    fi

    tar xzf "$CACHE_DIR/package/${package}.tgz" -C "$location"
}

function indent() {
    c='s/^/       /'
    case $(uname) in
        Darwin) sed -l "$c";;
        *)      sed -u "$c";;
    esac
}

function install_composer_deps() {
    local cwd=$(pwd)
    local target="$1"

    if [ ! -f "$target/composer.json" ]; then
        return 0
    fi

    export COMPOSER_CACHE_DIR=$CACHE_DIR/composer
    mkdir -p $COMPOSER_CACHE_DIR
    mkdir -p "$target/vendor/composer/bin"

    echo "-----> Vendoring Composer"
    if [ -f "$CACHE_DIR/composer.phar" ]; then
        {
            php "$CACHE_DIR/composer.phar" self-update
        } | indent
    else
        {
            curl -L "http://getcomposer.org/composer.phar" > "$CACHE_DIR/composer.phar"
            chmod a+x "$CACHE_DIR/composer.phar"
        } | indent
    fi

    local required_extensions=$(jq --raw-output '.require | keys | .[]' < "$BUILD_DIR/composer.json" | grep '^ext-' | sed 's/^ext-//')
    if [ -n "$required_extensions" ]; then
        echo "-----> Bundling additional extensions $required_extensions"
        for ext in $required_extensions; do
            echo "$ext" | indent
            fetch_package "ext/$(php_api_version)/php-${ext}" "/app/vendor/php" | indent
        done
    fi

    cp "$CACHE_DIR/composer.phar" "$target/vendor/composer/bin/"

    echo "-----> Installing application dependencies with Composer"
    {
        cd "$target"
        php "$target/vendor/composer/bin/composer.phar" install \
            --prefer-dist \
            --optimize-autoloader \
            --no-interaction \
            --no-dev

        if (($? > 0)); then
            exit 1
        fi

        cd "$cwd"
    } | indent
}

function mktmpdir() {
    dir=$(mktemp -t php-$1-XXXX)
    rm -rf $dir
    mkdir -p $dir
    echo $dir
}

function php_api_version() {
    basename "$(php-config --extension-dir)" | tr '-' ' ' | cut -f 5 -d ' '
}

function install_newrelic() {
    echo "-----> Enabling Newrelic support"

    local version="$1"
    local cwd=$(pwd)
    local ext_dir=/app/vendor/php/lib/php/extensions/no-debug-non-zts-$(php_api_version)
    local tempdir=$(mktmpdir "newrelic")
    cd "$tempdir"

    curl --silent -L "http://download.newrelic.com/php_agent/archive/${version}/newrelic-php5-${version}-linux.tar.gz" | tar xz
    mkdir -p $BUILD_DIR/vendor/newrelic/{bin,etc}
    cd "newrelic-php5-${version}-linux"

    cp -f "daemon/newrelic-daemon.x64" $BUILD_DIR/vendor/newrelic/bin/newrelic-daemon
    cp -f "agent/x64/newrelic-$(php_api_version).so" "${ext_dir}/newrelic.so"
    cp -f "$basedir/../conf/php/newrelic.ini" "/app/vendor/php/etc/conf.d/newrelic.ini"

    cd "$cwd"
}

function package_document_root() {
    jq --raw-output '.extra.heroku["document-root"] // ""' < "$BUILD_DIR/composer.json"
}

function package_index_file() {
    jq --raw-output '.extra.heroku["index-document"] // "index.php"' < "$BUILD_DIR/composer.json"
}

function package_framework() {
    jq --raw-output '.extra.heroku.framework // ""' < "$BUILD_DIR/composer.json"
}

function package_nginx_version() {
    jq --raw-output ".extra.heroku.engines.nginx // \"default\"" < "$BUILD_DIR/composer.json"
}

function package_php_version() {
    jq --raw-output ".extra.heroku.engines.php // \"default\"" < "$BUILD_DIR/composer.json"
}

function package_php_config() {
    jq --raw-output '.extra.heroku["php-config"] // [] | .[]' < "$BUILD_DIR/composer.json"
}

function package_php_includes() {
    jq --raw-output '.extra.heroku["php-includes"] // [] | .[]' < "$BUILD_DIR/composer.json"
}

function package_nginx_includes() {
    jq --raw-output '.extra.heroku["nginx-includes"] // [] | .[]' < "$BUILD_DIR/composer.json"
}

function package_compile_cmd() {
    jq --raw-output '.extra.heroku["compile"] // [] | .[]' < "$BUILD_DIR/composer.json"
}

function package_newrelic_enabled() {
    local val=$(jq --raw-output '.extra.heroku["newrelic"] // false' < "$BUILD_DIR/composer.json")

    if [ "$val" = "true" ]; then
        return 0
    else
        return 1
    fi
}

# Download jq binary for JSON processing
export PATH="$HOME/bin:$PATH"
curl "http://${S3_BUCKET}.s3.amazonaws.com/jq/jq" -L -s -o - > "$HOME/bin/jq"
chmod +x "$HOME/bin/jq"

DEFAULT_PHP="5.5.3"
DEFAULT_NGINX="1.4.2"

AVAILABLE_PHP_VERSIONS=$(curl "http://${S3_BUCKET}.s3.amazonaws.com/manifest.php" 2> /dev/null)
AVAILABLE_NGINX_VERSIONS=$(curl "http://${S3_BUCKET}.s3.amazonaws.com/manifest.nginx" 2> /dev/null)

MCRYPT_VERSION="2.5.8"
PHP_VERSION="default"
NGINX_VERSION="default"
DOCUMENT_ROOT=
INDEX_DOCUMENT="index.php"
FRAMEWORK=
PHP_EXTRA_CONFIG=
PHP_INCLUDES=
COMPILE_CMD=
NGINX_INCLUDES=
NEWRELIC_VERSION=4.0.5.18

# Read config variables from composer.json if it exists
if [ -f "$BUILD_DIR/composer.json" ]; then
    PHP_VERSION=$(package_php_version)
    NGINX_VERSION=$(package_nginx_version)
    DOCUMENT_ROOT=$(package_document_root)
    INDEX_DOCUMENT=$(package_index_file)
    FRAMEWORK=$(package_framework)
    PHP_EXTRA_CONFIG=$(package_php_config)
    PHP_INCLUDES=$(package_php_includes)
    COMPILE_CMD=$(package_compile_cmd)
    NGINX_INCLUDES=$(package_nginx_includes)
fi

if [ "$PHP_VERSION" = "default" ]; then
    PHP_VERSION="$DEFAULT_PHP"
fi

if [ "$NGINX_VERSION" = "default" ]; then
    NGINX_VERSION="$DEFAULT_NGINX"
fi

# Look for ".*" versions, match them against all available versions
# and select the latest version which was found.
if echo "$PHP_VERSION" | grep '\*' &>/dev/null; then
    PHP_VERSION=$(echo "$AVAILABLE_PHP_VERSIONS" | grep "^$PHP_VERSION$" | sort -r | head -n1)
fi

if echo "$NGINX_VERSION" | grep '\*' &>/dev/null; then
    NGINX_VERSION=$(echo "$AVAILABLE_NGINX_VERSIONS" | grep "^$NGINX_VERSION$" | sort -r | head -n1)
fi

VENDORED_NGINX=$(mktmpdir nginx)
VENDORED_PHP=$(mktmpdir php)

[ ! -d "$BUILD_DIR/vendor" ] && mkdir -p "$BUILD_DIR/vendor"

echo "-----> Bundling NGINX ${NGINX_VERSION}"
fetch_engine_package nginx "$NGINX_VERSION" "$VENDORED_NGINX" | indent

echo "-----> Bundling PHP ${PHP_VERSION}"

# Install libraries also on build container, so PHP doesn't wayne about missing
# dynamic libraries when running it during the slug compilation.
fetch_package "libicu-51" /app/vendor/libicu > /dev/null
fetch_package "libmcrypt-${MCRYPT_VERSION}" /app/vendor/libmcrypt > /dev/null

fetch_engine_package php "$PHP_VERSION" /app/vendor/php | indent

test ! -d ".profile.d" && mkdir -p .profile.d || true

cat > ".profile.d/php.sh" <<SH
export PATH=/sbin:/bin:/usr/sbin:/usr/bin:/app/bin:/app/vendor/nginx/sbin:/app/vendor/php/sbin:/app/vendor/php/bin:/app/vendor/bin:\$PATH
SH

source ".profile.d/php.sh"

# export PHP_INI_SCAN_DIR="$BUILD_DIR/vendor/php/etc/conf.d"
# export PATH=$BUILD_DIR/vendor/nginx/sbin:$BUILD_DIR/vendor/php/bin:$BUILD_DIR/vendor/php/sbin:$PATH
# EXTENSION_DIR="$BUILD_DIR/vendor/php/lib/php/extensions/no-debug-non-zts-$(php_api_version)"

# Temporarily set the extension dir relative to the build dir so
# dynamically loaded extensions (like redis or mongo) are available at build time.
# echo "extension_dir=$EXTENSION_DIR" > $BUILD_DIR/vendor/php/etc/conf.d/00_extensions.ini

# Disable opcache at build time so php doesn't warn us that it couldn't load
# the opcache extension because of the hardcoded paths not matching the build environment.
# sed -e 's/^/;/' --in-place="" $BUILD_DIR/vendor/php/etc/conf.d/opcache.ini

# Fetch additional extensions
echo "-----> Bundling extensions"
echo "       phpredis"
fetch_package "ext/$(php_api_version)/php-redis" "/app/vendor/php" | indent
echo "       mongo"
fetch_package "ext/$(php_api_version)/php-mongo" "/app/vendor/php" | indent

if [ -f "$BUILD_DIR/composer.json" ] && package_newrelic_enabled; then
    install_newrelic "$NEWRELIC_VERSION"
fi

if [ -n "$BUILDPACK_DEBUG" ]; then
    ls -R vendor/nginx
    ls -R vendor/php
fi

mkdir -p "conf"
cp "$basedir/../conf/nginx/base.conf.erb" "conf/nginx.conf.erb"
cp "$basedir/../conf/php/php-fpm.conf" "/app/vendor/php/etc/php-fpm.conf"
cp "$basedir/../conf/php/php.ini" "/app/vendor/php/etc/php.ini"

for conf in $PHP_EXTRA_CONFIG; do
    echo "$conf" >> "/app/vendor/php/etc/php.ini"
done

for include in $PHP_INCLUDES; do
    cp "$BUILD_DIR/$include" "vendor/php/etc/conf.d"
done

# Detect PHP framework
for f in "$basedir/../frameworks/"*; do
    if "$f" detect "$BUILD_DIR"; then
        FRAMEWORK="$f"
    fi
done

# Fall back to classic mode
if [ -z "$FRAMEWORK" ]; then
    FRAMEWORK="$basedir/../frameworks/default"
fi

if [ ! -f "$FRAMEWORK" ] && [ -f "$basedir/../frameworks/$FRAMEWORK" ]; then
    FRAMEWORK="$basedir/../frameworks/$FRAMEWORK"
fi

if [ -n "$FRAMEWORK" ] && [ -f "$FRAMEWORK" ]; then
    "$FRAMEWORK" compile "$BUILD_DIR" "$CACHE_DIR"
fi

install_composer_deps "$BUILD_DIR"

if [ -n "$COMPILE_CMD" ]; then
    echo "-----> Running compile commands"
    for cmd in "$COMPILE_CMD"; do
        {
            echo "Running '$cmd'"
            eval "$cmd"
        } | indent
    done
fi

echo "-----> Vendoring binaries into slug"
cp -R /app/vendor/libmcrypt/ vendor/libmcrypt
cp -R /app/vendor/libicu/ vendor/libicu
cp -R /app/vendor/nginx/ vendor/nginx
cp -R /app/vendor/php/ vendor/php

mkdir -p "bin"
# rm $BUILD_DIR/vendor/php/etc/conf.d/00_extensions.ini
# Enable opcache again
# sed -e 's/^;//' --in-place="" $BUILD_DIR/vendor/php/etc/conf.d/opcache.ini

cat > "bin/run" <<SH
#!/usr/bin/env bash

for var in \`env | cut -f1 -d=\`; do
    echo "env[\$var] = \\$\${var}" >> /app/vendor/php/etc/php-fpm.conf
done

export DOCUMENT_ROOT="$DOCUMENT_ROOT"
export INDEX_DOCUMENT="$INDEX_DOCUMENT"
export NGINX_INCLUDES="$NGINX_INCLUDES"

if [ -n "\$NEW_RELIC_LICENSE_KEY" ]; then
    echo "newrelic.license=\"\$NEW_RELIC_LICENSE_KEY\"" > /app/vendor/php/etc/conf.d/newrelic_license.ini
fi

erb conf/nginx.conf.erb > /app/vendor/nginx/conf/nginx.conf
erb conf/site.conf.erb > /app/vendor/nginx/conf/site.conf

mkdir -p /app/vendor/nginx/logs
mkdir -p /app/vendor/php/var/log
mkdir -p /app/vendor/php/run

touch /app/vendor/nginx/logs/access.log \
      /app/vendor/nginx/logs/error.log

touch /app/vendor/php/var/log/error.log

(tail -qF -n 0 /app/vendor/nginx/logs/access.log /app/vendor/nginx/logs/error.log /app/vendor/php/var/log/*.log &)

php-fpm -p "/app/vendor/php"
nginx -p "/app/vendor/nginx" -c /app/vendor/nginx/conf/nginx.conf
SH

chmod a+x "bin/run"
